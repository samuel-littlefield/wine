---
title: "Wine Analysis"
author: "Samuel Littlefield"
date: "5/31/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(readr)
library(dplyr)
library(ggplot2)
library(corrplot)
library(RCurl)
```

## Introduction

For this analysis, we will be looking at a data set which describes a collection of wines. Our data set does not contain the names of the wines, their varietals, or the wineries from which they have been produced. All the information we have is present in the data we received from our client via csv.


## Goals

The goals of our analysis are to complete the requirements provided by our client, and bring attention to findings that may be of value to the client. The client's requested items will be listed as headers above the the respective section of the analysis.


## Tools Used

This analysis was conducted in and is being shared via __RMarkdown__. The selected coding language for working with our data is __R__, along with five additional packages. These packages are __readr__ and __RCurl__ for importing our data, __dplyr__ which provides additional data wrangling and transformation capabilities, and both __ggplot2__ and __corrplot__ which allow the provision of data visualization.

All of these packages were successfully loaded at the beginning of this analysis.

## Importing the Data
#### Client Request #1: Import the Wine.csv file and name the dataframe “Wine”.

We'll begin by importing the Wine.csv from GitHub using both __readr__ and __RCurl__ then changing the object type to a data frame.

```{r import data, message=FALSE}
Wine <- as.data.frame(read.csv(text = getURL("https://raw.githubusercontent.com/samuel-littlefield/wine/main/Wine.csv")))
```
_Note that the `message = FALSE` parameter was added to the code chunk to prevent printing of the output message generated by this code._


## Data Description
#### Client Request #2: Describe the structure of the Wine data frame immediately after import.

For this section, our client has provided the following requirements:

- What is the dimension of the data frame?
- What are the numeric/integer variables?
- What are the character variables?


To meet the client's need, we'll start by running a simple function to get the structure of our data set, from which we can both identify the dimensions and the types of variables we currently have to work with.

We'll run this now.

```{r Wine structure}
str(Wine)
```

Looking at the output above, it appears that our data set is comprised of 178 rows and 14 columns. That information is listed above as "178 obs of 14 variables". We can also see that only one variable is a character data type:

 - Type

The remaining 13 variables are all the numeric data type:

 - Alcohol
 - Malic_Acid
 - Ash
 - Ash_Alcalinity
 - Magnesium
 - Total_Phenols
 - Flavanoids
 - Nonflavanoid_Phenols
 - Proanthocyanins
 - Color_Intensity
 - Hue
 - OD280_OD315
 - Proline

This concludes our Data Description section. We will now move on to formatting.

## Formatting
#### Client Request #3: Format structure/types of data.

For this section, the client has provided the following requirements:

- Type should be a factor.
- All other columns should be numeric or integer.

As previously mentioned, all of our variables are numeric with the exception of Type. To fulfill our client's requirements for this section, we only need to change the data type of the Type variable.

We'll make this update now.

```{r Wine formatting}
Wine$Type <- as.factor(Wine$Type)
```

Since we've changed the data type to a factor, it's good practice to review the levels of any variables that are a factor data type. This helps to ensure we have consistent factors and don't get any unexpected results later down the road. 

We'll check this now.

```{r check factors}
levels(Wine$Type)
```
As we can see in the output above, we have three independent levels in our Type factor. None of these levels are duplicates of one another so no further updates or corrections are needed.

This concludes our formatting process. Next, we'll move on to data cleansing.

## Data Cleansing
#### Client Request #4: Clean the data.

For our data cleansing process, the client has provided the following requirements:

- Duplicates, if any, should be removed.
- Any observations missing the type value should be removed.
- Any observations missing a numeric or integer value should have the missing value set to the average of that column.

To start, we'll remove any potential duplicates. Before doing so, we'll create a copy of our data for future reference when needed.

We'll do both of these actions now.

```{r remove dupes}
Wine_original <- as.data.frame(Wine)
Wine <- distinct(as.data.frame(Wine))
```

We now have an original copy of our data and any existing duplicates would have been removed from our data set. Next, we'll compare both data sets to identify if any duplicates were found.

```{r check if dupes found}
dim(Wine_original) == dim(Wine)
```

Because the output returned both "TRUE" and "TRUE" this tells us that the row and variable counts are still equal between our original and working copies of the data set. This tells us that we did not have any duplicates. Since we do not have any column, or potential subset of columns, to use as a unique identifier, the steps we've taken up to this point should be sufficient for identifying and removing any potential duplicates. We will now assume that our data set is free of duplicate values and move forward.

Next, we'll check for missing values. Staring with "NA" values.

```{r identify NA values}
sum(is.na(Wine$Type))
sum(is.na(Wine$Alcohol))
sum(is.na(Wine$Malic_Acid))
sum(is.na(Wine$Ash))
sum(is.na(Wine$Ash_Alcalinity))
sum(is.na(Wine$Magnesium))
sum(is.na(Wine$Total_Phenols))
sum(is.na(Wine$Flavanoids))
sum(is.na(Wine$Nonflavanoid_Phenols))
sum(is.na(Wine$Proanthocyanins))
sum(is.na(Wine$Color_Intensity))
sum(is.na(Wine$Hue))
sum(is.na(Wine$OD280_OD315))
sum(is.na(Wine$Proline))
```

Looks like we have two "NA" values, one in the Proanthocyanins variable and the other in the Flavanoids variable. 

We'll now replace these missing values with the mean of the respective column.

```{r replace NA Values}
Wine$Proanthocyanins[is.na(Wine$Proanthocyanins)] <- mean(Wine$Proanthocyanins, na.rm = TRUE)
Wine$Flavanoids[is.na(Wine$Flavanoids)] <- mean(Wine$Flavanoids, na.rm = TRUE)
```

If we now run the same lines of code which previously found our missing values, __R__ will return 0s since we've now entered mean values in place of the "NA" values which were previously found.

We will demonstrate this next to ensure that our changes were successful.

```{r validate NA Correction}
sum(is.na(Wine$Flavanoids))
sum(is.na(Wine$Proanthocyanins))
```

Great! Both lines of code returned 0s. Our changes were successful and we've corrected all identified "NA" values in our data. Before we move on, it's important to note that __R__ treats "NA" and "NULL" values differently, even though they are both considered missing values. Therefore, we still need to check for "NULL" values. 

We can check our data set for "NULL" values by comparing the length of each variable with the row count of the data set. In any instance where __R__ returns "FALSE" this indicates that the overall row count is different from the count of values in the variable, which may be alerting us to a "NULL" value in that variable.

We'll now check for "NULL" values in our data set.

```{r identify NULL values}
nrow(Wine) == length(Wine$Type)
nrow(Wine) == length(Wine$Alcohol)
nrow(Wine) == length(Wine$Malic_Acid)
nrow(Wine) == length(Wine$Ash)
nrow(Wine) == length(Wine$Ash_Alcalinity)
nrow(Wine) == length(Wine$Magnesium)
nrow(Wine) == length(Wine$Total_Phenols)
nrow(Wine) == length(Wine$Flavanoids)
nrow(Wine) == length(Wine$Nonflavanoid_Phenols)
nrow(Wine) == length(Wine$Proanthocyanins)
nrow(Wine) == length(Wine$Color_Intensity)
nrow(Wine) == length(Wine$Hue)
nrow(Wine) == length(Wine$OD280_OD315)
nrow(Wine) == length(Wine$Proline)
```

Great! For all outputs, __R__ returned "TRUE", meaning we don't have any "NULL" values in any of our variables. This also means that since we had no missing values in the Type variables, that we don't have to remove any rows from our data set as specified in our requirements.

This concludes our data cleansing section.

## Data Summary
#### Client Request #5	Summarize the numeric variables. 

For this next section, our client has provided the following requirements:

- Be sure to examine the minimum, first quartile, median, mean, third quartile, and maximum.

We can accomplish all of the items in this requirement with a single function in __R__. However, since our data contains a factor, we'll have to remove this variable in order for the function to work properly. We'll create a subset of our data and name it "Wine_summary" which we'll then feed into our function.

First, let's create the needed subset.

```{r create Wine_summary}
Wine_summary <- subset (Wine, select = -Type)
```

How that we have a subset of our data set containing only numeric type variables, we'll use this subset with our function to get our data summary.

Let's now produce summary.

```{r data summary}
summary(Wine_summary)
```

As seen in the output above, we now have a summary of each numeric variable in our data set. This makes all summary information in the client's requirements easily accessible. We won't go over each variable individually, as this would be redundant, but we will examine the summary of our Alcohol variable as an example:

- _Min._: The minimum value of our Alcohol variable is __11.03__. This tells us that all wines in our data set have a recorded Alcohol level of 11.03 or higher.

- _1st Qu._: The first quartile value of our Alcohol variable is __12.36__. This means that 12.36 is the median of the lower half of the data in this variable. This also tells us that about 25% of the records in this variable are lower than 12.36, while 75% of those records are above 12.36.

- _Median_: The median of our Alcohol variable is __13.05__. This means that if we listed all of the values in the Alcohol variable and sorted them in either ascending or descending order, 13.06 would in the middle point of that list. Because our variables have 178 entries, giving us an even number of records, the value of 13.06 is the average of the two middle records.

- _Mean_: The mean value of our Alcohol variable is __13.00__. This tells us that if we added all of the values in the Alcohol variable together and divided that sum by the number of records (178) we would get 13.00.

- _3rd Qu._: The third quartile value of our Alcohol variable is __13.68__. This means that 13.68 is the median of the upper half of the data in this variable. This also tells us that about 75% of the records in this variable are lower than 13.68, while 25% of those records are above 13.68.

- _Max._: The maximum value of our Alcohol variable is __14.83__. This tells us that all wines in our data set have a recorded Alcohol level of 14.83 or lower.

How is this summary information useful? This greatly depends on the client's use case and desired actionable outcomes. Let's say for example that the client is evaluating the market for new opportunities, and it turns out that the data we're looking at in this analysis is comprised of competitor's wines currently in the market. According to an article from [www.realsimple.com](https://www.realsimple.com/holidays-entertaining/entertaining/food-drink/alcohol-content-wine), for wine, anything under 12.5 is considered very low alcohol content while very high is more that 14.5. Going off of this information, if we consider that the mean and median both are greater than 12.5 and our maximum only slightly exceeds 14.5, this may be a good indicator that it might be worth considering opportunities for wines with higher alcohol content, as there appears to be less competitor products in this area. Perhaps a wine beverage with higher alcohol content could find a good place in our market. Our data summary at this level will by no means guarantee success for this potential product, but it certainly can give our client some insights which can become useful in the decision making process.

This completes our data summary.

## Adding a Factor
#### Client Request #6	Create a new factor variable called high_Magnesium. 

Our client's requirements for this section is as follows:

- If the Magnesium level is less than 100, set the value to “low.” Otherwise, the value is “high.”

The client has asked that we add an additional variable and name it "high_Magnesium". We will add this variable to our data frame and fill it with the appropriate value based on the client's provided logic.

We'll add this variable, complete with data, now.

```{r create high_Magnesium}
Wine["high_Magnesium"] <- ifelse(Wine$Magnesium<100, "low", "high")
```

Next, we'll change the data type to factor.

```{r change high_Magnesium to factor}
Wine$high_Magnesium <- as.factor(Wine$high_Magnesium)
```

We'll now check the levels of our new factor. This will allow us to see that both of our previous lines of code worked as expected.

```{r high_Magnesium factor levels}
levels(Wine$high_Magnesium)
```

Great! We can see that our column did return the levels "high" and "low". This confirms that our new variable was added successfully, that we changed the data type correctly, and that the levels of this new factor are consistent.

With our factor added, and checked for consistency, we've now completed the requirements for this section.

## Malic_Acid Boxplot
#### Client Request #7	Create a boxplot of Malic_Acid. 

For this item, we'll create our first visual from the data set. We'll use a function from __ggplot2__ to create the boxplot, then display it.

```{r create Malic_Acid Boxplot }
box_plot <- ggplot(Wine, aes(y=Malic_Acid)) + geom_boxplot()
box_plot
```

Looking at our boxplot for Malic_Acid, we can observe the minimum, maximum, 1st and 3rd quartiles, median, and three possible outliers in a single visualization.

The requested visual is delivered as specified, completing this request.

## Malic_Acid and Ash Scatterplot
#### Client Request #8:	Create a scatterplot of Malic_Acid and Ash. 

To pair with the second requested visualization, we've recieved the following requirements:

- Add a trend line. 
- Add labels to the plot.

This next requested visual needs to be a scatterplot, plotting the wines by the values of their Malic_Acid and Ash variables.

We'll create this visual next again with the help of __ggplot2__.

```{r create Malic_Acid and Ash Scatterplot, message=FALSE}
scatter_plot <- ggplot(data = Wine, aes(x=Malic_Acid, y = Ash)) 
scatter_plot <- scatter_plot + geom_point() 
scatter_plot <- scatter_plot + geom_smooth(method='lm')
scatter_plot <- scatter_plot + labs(title = "Malic Acid and Ash",
                                    x="Malic Acid", y="Ash")
scatter_plot
```

Looking at our scatterplot, the trendline indicates that as the level of Ash increases in wine, so does the Malic Acid at a slight level.

This completes our Malic_Acid and Ash scatterplot.

## Boxplots for Proline and Type
#### Client Request #9: Create three boxplots (on the same graph) of Proline by Type. 

Our third visual needs to meet the following requirements:

- Add labels to the plots. 
- Fill the boxes with the color.

For this next visualization request, the client has specified that they'd like the see the Proline of our wines but in three separate boxplots separated by Type, but all in a single visual.

We'll generate our visual with the requirements in mind.

```{r create Proline Boxplots}
box_plot2 <- ggplot(Wine, aes(x=Type, y=Proline)) + geom_boxplot() 
box_plot2 <- box_plot2 + geom_boxplot(color="black", fill="blue", alpha=0.8)
box_plot2 <- box_plot2 + labs(title = "Proline vs. Type")
box_plot2
```

With the visualization complete, we know have provided our client with a useful visual for understanding how Proline differs between our three types of wines found in our data set. We can tell for example that types B and C are more closely related in their Proline values than type A, as the boxplot for type A sits significantly higher on the y axis than both B and C, which are more similar in their breath across the y axis.

This completes our boxplots visual for Proline and Type.

## Wine_A Data Frame
#### Client Request #10: Create a new data frame called Wine_A, where the only data is Type “A” and Magnesium > 100. 

For this request, our client also provided the following requirement:

- Show the first five rows of this new data frame.

To complete this request, we'll start by creating a new data frame named "Wine_A" which only contains wines from our Wine data frame where the Type is equal to "A".

We'll create this new data frame now.

```{r create Wine_A}
Wine_A <- Wine[Wine[,"Type"]=="A",]
```

Next, we'll filter the rows down in our Wine_A data frame so that only those wines with a "Magnesium" value greater than 100 remain.

```{r filter Wine_A}
Wine_A <- Wine_A[Wine_A[,"Magnesium"]>100,]
```

And finally, we'll show only the first five rows of this new data frame, as requested by our client.

```{r Wine_A First 5 Rows}
head(Wine_A, n=5)
```

This completes our work with the new data frame.

## Average of Alcohol
#### Client Request #11: Display the average of alcohol by type

To meet this request, we'll produce an aggregate in __R__ and view the output.

We'll do this now.

```{r create Aggregate - Avg Alcohol by Type}
aggregate(Alcohol ~ Type, Wine, mean)
```

By viewing the output, we can see that on average the wines in Type A have higher alcohol content than the wines in both Types B and C. We can also see that on average the wines in Type B are lower than those found in Types A and C.

This completes our aggregation for Alcohol by Type.

## Pearson's Correlation
#### Client Request #12: Using the package corrplot, report the Pearson’s correlation coefficients for the numeric variables. 

For the final visualization of our analysis, the client has given the following requirements: 

- Remove the top half of the chart and the diagonal. 
- Are there variables that are correlated?

For the final visualization, we'll use a different package, __corrplot__, to review the Pearson's correlation coefficients between the numeric variables in our data set.

In order to work successfully, we'll need to input data into __corrplot__ that is limited to numeric values only. Fortunately for us, since the "high_Magnesium" variable we added earlier is a factor, we can reuse the Wine_summary subset we created earlier.

We'll create our visual now.

```{r Correlation Plot}
wine_plot3 <- cor(Wine_summary, method=c('pearson'))
corrplot(wine_plot3, type="lower", diag=FALSE)
```

It appears that there are quite a few correlations identified and shown in our visual. The correlations are indicated by the dots which vary in both size and color. Thanks to the color legend located directly below our visual, we can tell that the more blue a dot is, the stronger a positive correlation is. As noted by the opposite end of our color legend, the more red a dot is, the stronger the negative correlation is.

As we can see, there are quite a few correlations going on in our data set between variables, and those correlations fall across a wide range of strength in both positive and negative relationships. We won't review all of these correlations, but let's make mention of a few as examples for our client:

- _Flavanoids and Total_Phenols_: This appears to have the strongest positive relationship between two variables in our data set. This is noted by having the largest and darkest of the blue dots seen in our visual.

- _Flavanoids and OD280_OD315_: The relationship between these variables seems to be a close second for the strongest positive relationship in our data set.

- _Hue and Malic_Acid_: These two variables appear to have the strongest negative relationship between any two variables in our data set. As can be seen by how red and large the dot is where these two variables intersect on the visual.

This completes our Pearson's correlation coefficients visual.

## Closing Remarks

Through this analysis we have completed all of the requirements provided to us by our client. Our data was imported, cleaned, and used to produce a variety of visualizations and summaries which will should provide our client with valuable insights into the provided data set. We've made it a point to explain the items in our analysis and how they may be of value. We wish the client the very best in their decision making process beyond this analysis.